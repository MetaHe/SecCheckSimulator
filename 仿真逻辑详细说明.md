# 安检仿真系统详细逻辑说明

## 概述

这个仿真系统基于**SimPy离散事件仿真框架**，模拟35,000名观众在3.5小时内通过安检进站的完整过程。系统通过精确建模每个观众的完整旅程，为大型活动安检规划提供科学的决策支持。

---

## 🏗️ 1. 核心架构

### 1.1 SpectatorStats类 - 观众数据记录器

每个观众都有一个专属的数据记录器，追踪其在仿真过程中每个环节的详细时间数据：

```python
class SpectatorStats:
    def __init__(self, id, arrival_time):
        self.id = id                          # 观众唯一标识
        self.arrival_time = arrival_time      # 到达公园时间
        self.transport_delay = 0              # 交通延迟时间
        self.walk_duration = 0                # 步行耗时
        self.security_queue_wait_time = 0     # 安检排队等待时间
        self.security_process_time = 0        # 安检处理时间
        self.descend_queue_wait_time = 0      # 下楼排队等待时间
        self.descend_process_time = 0         # 下楼过程时间
        self.descend_method = ""              # 下行方式选择
        self.finish_time = -1                 # 完成进站时间
        self.is_finished = False              # 是否成功完成
```

**关键特性**：
- 完整生命周期追踪
- 多维度时间记录
- 个性化行为标记

### 1.2 Simulation类 - 仿真主控制器

```python
class Simulation:
    def __init__(self):
        self.env = simpy.Environment()        # SimPy仿真环境
        self.random_state = np.random.RandomState(cfg.RANDOM_SEED)
        
        # 资源定义
        self.security_lanes = [...]           # 12条安检通道
        self.north_lanes = [...]              # 北侧6条通道
        self.south_lanes = [...]              # 南侧6条通道
        self.escalator = simpy.Resource(...)  # 扶梯资源
        self.stairs = simpy.Resource(...)     # 楼梯资源（无限容量）
        
        # 数据收集
        self.spectator_stats = []             # 所有观众数据
        self.system_state_log = []            # 系统状态监控数据
```

**架构亮点**：
- 资源池管理（安检通道、扶梯、楼梯）
- 南北分区策略
- 双重数据收集机制

---

## 🎯 2. 仿真初始化流程

### 2.1 观众生成策略

```python
def setup(self):
    self.env.process(self.monitor())          # 启动系统监控器
    for i in range(cfg.TOTAL_SPECTATORS):    # 生成35,000名观众
        # 观众在3.5小时内均匀随机到达
        arrival_time = self.random_state.uniform(0, cfg.SIMULATION_DURATION_SECONDS)
        self.env.process(self.spectator_arrival(i, arrival_time))
```

**关键设计决策**：
- **均匀分布到达**：模拟观众在整个时间窗口内持续到达
- **独立进程**：每个观众都是独立的仿真进程，支持并发处理
- **确定性随机**：使用固定随机种子确保结果可复现

### 2.2 并发控制机制

- **35,000个观众进程**：每个观众独立并发执行完整流程
- **1个监控进程**：定期记录系统状态快照
- **SimPy事件调度器**：自动处理时间推进和资源竞争

---

## 👥 3. 单个观众完整流程

### 3.1 阶段1：交通延迟模拟

```python
def get_transport_delay(self):
    # 根据概率分布选择交通方式
    mode = self.random_state.choice(
        list(cfg.TRANSPORT_PROBS.keys()), 
        p=list(cfg.TRANSPORT_PROBS.values())
    )
    
    delay = 0
    if mode == "自驾":
        # 正态分布：均值5分钟，标准差2分钟
        delay = self.random_state.normal(cfg.DRIVE_DELAY_MEAN_S, cfg.DRIVE_DELAY_STD_S)
    elif mode == "公交":
        # 均匀分布：0-8分钟
        delay = self.random_state.uniform(cfg.BUS_DELAY_MIN_S, cfg.BUS_DELAY_MAX_S)
    
    return max(0, delay)
```

**交通方式概率分布**：
- 自驾：30% → 正态分布延迟
- 公交：40% → 均匀分布延迟
- 出租车：15% → 无延迟
- 步行：10% → 无延迟
- 自行车：5% → 无延迟

### 3.2 阶段2：公园内步行

```python
def get_path_details(self):
    # 路径长度：100-500米均匀分布
    path_length = self.random_state.uniform(cfg.PATH_LENGTH_MIN_M, cfg.PATH_LENGTH_MAX_M)
    # 随机扰动：1-3分钟均匀分布
    random_delay = self.random_state.uniform(cfg.PATH_DISTURBANCE_MIN_S, cfg.PATH_DISTURBANCE_MAX_S)
    return path_length, random_delay

# 在spectator_process中执行：
path_length, stats.walk_delay_random = self.get_path_details()
stats.walk_duration = path_length / cfg.BASE_WALKING_SPEED_MPS  # 基础步行时间
yield self.env.timeout(stats.walk_duration)                    # 执行步行
yield self.env.timeout(stats.walk_delay_random)                # 随机扰动
```

**步行模型参数**：
- **基础速度**：1.2米/秒
- **路径长度**：100-500米（均匀分布）
- **随机扰动**：1-3分钟（模拟意外情况、拍照等）

### 3.3 阶段3：智能安检大棚选择

```python
# 3.1 大棚级别选择：比较南北两个大棚的总排队人数
north_queue = sum(len(res.queue) for res in self.north_lanes)
south_queue = sum(len(res.queue) for res in self.south_lanes)
chosen_tent_lanes = self.north_lanes if north_queue <= south_queue else self.south_lanes

# 3.2 通道级别选择：在选定大棚内选择排队最少的具体通道
chosen_lane = min(chosen_tent_lanes, key=lambda r: len(r.queue))
```

**智能调度算法**：
1. **第一层决策**：南北大棚选择
   - 实时比较两个大棚的总排队人数
   - 选择排队人数少的大棚
2. **第二层决策**：具体通道选择
   - 在选定大棚内比较各通道排队情况
   - 选择排队最少的通道
3. **动态更新**：每个观众到达时重新评估

### 3.4 阶段4：复杂安检处理过程

```python
with chosen_lane.request() as request:
    yield request  # 排队等待通道可用
    stats.security_queue_wait_time = self.env.now - security_queue_start_time
    
    security_process_start_time = self.env.now
    
    # 安检失败重试循环
    while self.random_state.rand() < cfg.SECURITY_FAILURE_RATE:
        process_time = self.random_state.exponential(cfg.SECURITY_CHECK_TIME_MEAN_S)
        yield self.env.timeout(process_time)  # 失败处理时间

    # 正常安检处理
    process_time = self.random_state.exponential(cfg.SECURITY_CHECK_TIME_MEAN_S)
    yield self.env.timeout(process_time)
    
    stats.security_process_time = self.env.now - security_process_start_time

    # 通道故障处理
    if self.random_state.rand() < cfg.LANE_FAILURE_PROB_PER_PERSON:
        failure_duration = self.random_state.uniform(
            cfg.LANE_FAILURE_DURATION_MIN_S,
            cfg.LANE_FAILURE_DURATION_MAX_S
        )
        yield self.env.timeout(failure_duration)  # 故障恢复时间
```

**安检处理的多层复杂性**：
1. **排队等待**：使用SimPy资源管理器处理排队逻辑
2. **失败重试**：2%概率安检失败，需要立即重新安检
3. **正常处理**：指数分布时间（均值15秒）
4. **设备故障**：0.1%概率通道故障，停用2-10分钟

### 3.5 阶段5：动态下行方式选择

```python
# 初始概率设置
use_escalator_prob = cfg.DESCEND_INITIAL_PROBS['escalator']  # 40%

# 动态概率调整
if len(self.escalator.queue) > cfg.ESCALATOR_QUEUE_THRESHOLD_FOR_ADJUST:
    use_escalator_prob = cfg.DESCEND_ADJUSTED_PROBS['escalator']  # 降至30%

# 根据调整后概率选择下行方式
if self.random_state.rand() < use_escalator_prob:
    # 选择扶梯
    stats.descend_method = "escalator"
    with self.escalator.request() as request:
        yield request
        stats.descend_queue_wait_time = self.env.now - descend_queue_start_time
        descend_process_start_time = self.env.now
        yield self.env.timeout(1 / cfg.ESCALATOR_CAPACITY_PER_SEC)
        stats.descend_process_time = self.env.now - descend_process_start_time
else:
    # 选择楼梯
    stats.descend_method = "stairs"
    with self.stairs.request() as request:
        yield request
        stats.descend_queue_wait_time = self.env.now - descend_queue_start_time
        descend_process_start_time = self.env.now
        yield self.env.timeout(cfg.STAIRS_PERSON_CROSS_TIME_S)
        stats.descend_process_time = self.env.now - descend_process_start_time
```

**动态决策机制**：
- **初始状态**：扶梯40%，楼梯60%
- **拥堵调整**：扶梯队列>50人时，扶梯概率降至30%，楼梯升至70%
- **实时感知**：每个观众都能感知当前队列状态并智能决策

---

## 📊 4. 系统监控机制

### 4.1 实时状态监控

```python
def monitor(self):
    """定期记录系统状态快照"""
    while True:
        state = {
            "时间(s)": self.env.now,
            "北侧安检队列总人数": sum(len(r.queue) for r in self.north_lanes),
            "南侧安检队列总人数": sum(len(r.queue) for r in self.south_lanes),
            "北侧安检区使用中通道数": sum(r.count for r in self.north_lanes),
            "南侧安检区使用中通道数": sum(r.count for r in self.south_lanes),
            "电梯队列人数": len(self.escalator.queue),
            "电梯使用中人数": self.escalator.count,
            "楼梯使用中人数": self.stairs.count,
            "楼梯密度(人/米)": self.stairs.count / cfg.STAIRS_WIDTH_M
        }
        self.system_state_log.append(state)
        yield self.env.timeout(cfg.MONITOR_INTERVAL_S)  # 每60秒记录一次
```

### 4.2 监控指标体系

**队列监控**：
- 南北安检区队列长度
- 扶梯排队人数
- 实时队列状态变化

**资源利用率**：
- 安检通道使用率
- 扶梯利用率
- 楼梯人流密度

**系统性能**：
- 时间序列数据
- 峰值负载统计
- 瓶颈识别指标

---

## 🔄 5. 仿真执行流程

### 5.1 主控制循环

```python
def run(self):
    """运行完整仿真"""
    print("仿真开始...")
    self.setup()                                    # 初始化所有观众和监控器
    self.env.run(until=cfg.SIMULATION_DURATION_SECONDS)  # 运行3.5小时仿真
    print("仿真结束。")
```

### 5.2 事件调度机制

**SimPy离散事件调度**：
- 自动时间推进
- 事件优先级管理
- 资源竞争处理
- 并发进程协调

**进程管理**：
- 35,000个观众进程并发运行
- 1个系统监控进程
- 动态资源分配和释放

---

## 📈 6. 数据收集和输出

### 6.1 个体数据收集

```python
def to_dict(self):
    """将观众数据转换为字典格式"""
    return {
        "ID": self.id,
        "到达公园时间": self.arrival_time,
        "交通延迟": self.transport_delay,
        "步行时长": self.walk_duration,
        "安检排队时长": self.security_queue_wait_time,
        "安检处理时长": self.security_process_time,
        "下楼排队时长": self.descend_queue_wait_time,
        "下楼过程时长": self.descend_process_time,
        "下行方式": self.descend_method,
        "完成进站时间": self.finish_time,
        "是否在规定时间内完成": self.is_finished,
        "总耗时": self.total_time()
    }
```

### 6.2 数据输出格式

```python
def get_results(self):
    """生成分析用的DataFrame"""
    spectator_df = pd.DataFrame([s.to_dict() for s in self.spectator_stats])
    system_df = pd.DataFrame(self.system_state_log)
    return spectator_df, system_df
```

**输出文件结构**：
- `spectator_df`：35,000行观众个体数据
- `system_df`：系统状态时间序列数据
- Excel多工作表输出格式

---

## 🎯 7. 核心设计亮点

### 7.1 真实性建模

**统计分布选择**：
- 指数分布安检时间（符合服务时间特征）
- 正态分布交通延迟（符合现实情况）
- 多层次随机扰动（增加真实性）

**现实场景模拟**：
- 设备故障和恢复
- 人为操作失误
- 动态决策调整

### 7.2 智能决策系统

**多层决策架构**：
- 大棚选择 → 通道选择
- 初始概率 → 动态调整
- 个体理性 → 系统优化

**实时信息利用**：
- 队列长度感知
- 资源状态监控
- 自适应行为调整

### 7.3 可扩展性设计

**参数化配置**：
- 所有关键参数外部化
- 易于进行敏感性分析
- 支持多场景建模

**模块化架构**：
- 独立的功能模块
- 清晰的接口定义
- 易于扩展新功能

### 7.4 数据完整性

**多维度追踪**：
- 个体级详细记录
- 系统级实时监控
- 时间序列完整性

**分析支持**：
- 瓶颈识别
- 性能优化
- 决策支持

---

## 🔧 8. 技术实现特点

### 8.1 SimPy框架优势

**离散事件仿真**：
- 精确时间控制
- 复杂事件序列
- 资源竞争处理

**并发处理能力**：
- 大规模并发支持
- 高效内存管理
- 快速执行性能

### 8.2 数据结构优化

**内存效率**：
- 观众对象轻量化
- 增量数据收集
- 批量处理机制

**计算效率**：
- 向量化操作
- 缓存机制
- 懒加载策略

---

## 📊 9. 应用价值

### 9.1 决策支持

**容量规划**：
- 安检通道数量优化
- 人员配置建议
- 设施布局改进

**运营策略**：
- 排队管理优化
- 动态调度策略
- 应急预案制定

### 9.2 风险评估

**瓶颈识别**：
- 关键环节分析
- 峰值负载预测
- 故障影响评估

**性能预测**：
- 完成率预测
- 等待时间估算
- 资源利用率分析

---

## 🚀 10. 未来扩展方向

### 10.1 模型增强

**更复杂的行为模型**：
- 群体行为建模
- 学习适应机制
- 情绪状态影响

**更精细的物理模型**：
- 空间约束建模
- 拥挤效应模拟
- 路径优化算法

### 10.2 技术升级

**可视化增强**：
- 实时动画显示
- 3D场景渲染
- 交互式分析界面

**性能优化**：
- 并行计算支持
- GPU加速计算
- 分布式仿真

---

## 总结

这个安检仿真系统通过**离散事件建模**的方法，精确模拟了大规模人群流动的复杂动态过程。系统的核心价值在于：

1. **高保真度建模**：准确反映现实世界的复杂性和随机性
2. **智能决策支持**：为优化安检流程提供科学依据
3. **可扩展架构**：支持多种场景和策略的建模分析
4. **完整数据追踪**：提供全面的性能分析和瓶颈识别

通过这个仿真工具，活动组织者可以在实际部署前，通过数字化方式验证各种安检策略的效果，从而做出更加科学和经济的决策。 