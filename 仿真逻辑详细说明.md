# 安检仿真系统详细逻辑说明

## 概述

这个仿真系统基于**SimPy离散事件仿真框架**，模拟35,000名观众在3.5小时内通过安检进站的完整过程。系统通过精确建模每个观众的完整旅程，为大型活动安检规划提供科学的决策支持。

---

## 🏗️ 1. 核心架构

### 1.1 SpectatorStats类 - 观众数据记录器

每个观众都有一个专属的数据记录器，追踪其在仿真过程中每个环节的详细时间数据：

```python
class SpectatorStats:
    def __init__(self, id, arrival_time):
        self.id = id                          # 观众唯一标识
        self.arrival_time = arrival_time      # 到达公园时间
        self.transport_delay = 0              # 交通延迟时间
        self.walk_duration = 0                # 基础步行耗时（不含随机扰动）
        self.walk_delay_random = 0            # 步行过程中的随机扰动耗时
        self.security_queue_wait_time = 0     # 安检排队等待时间
        self.security_process_time = 0        # 安检处理时间
        self.descend_queue_wait_time = 0      # 下楼排队等待时间
        self.descend_process_time = 0         # 下楼过程时间
        self.descend_method = ""              # 下行方式选择
        self.finish_time = -1                 # 完成进站时间
        self.is_finished = False              # 是否成功完成
```

**关键特性**：
- 完整生命周期追踪
- 多维度时间记录
- 个性化行为标记

### 1.2 Simulation类 - 仿真主控制器

```python
class Simulation:
    def __init__(self):
        self.env = simpy.Environment()        # SimPy仿真环境
        self.random_state = np.random.RandomState(cfg.RANDOM_SEED)
        
        # 资源定义
        self.security_lanes = [...]           # 12条安检通道
        self.north_lanes = [...]              # 北侧6条通道
        self.south_lanes = [...]              # 南侧6条通道
        self.escalator = simpy.Resource(...)  # 扶梯资源
        self.stairs = simpy.Resource(...)     # 楼梯资源（无限容量）
        
        # 数据收集
        self.spectator_stats = []             # 所有观众数据
        self.system_state_log = []            # 系统状态监控数据
```

**架构亮点**：
- 资源池管理（安检通道、扶梯、楼梯）
- 南北分区策略
- 双重数据收集机制

---

## 🎯 2. 仿真初始化流程

### 2.1 观众生成策略

```python
def setup(self):
    self.env.process(self.monitor())          # 启动系统监控器
    for i in range(cfg.TOTAL_SPECTATORS):    # 生成35,000名观众
        # 观众在3.5小时内均匀随机到达
        arrival_time = self.random_state.uniform(0, cfg.SIMULATION_DURATION_SECONDS)
        self.env.process(self.spectator_arrival(i, arrival_time))
```

**关键设计决策**：
- **均匀分布到达**：模拟观众在整个时间窗口内持续到达
- **独立进程**：每个观众都是独立的仿真进程，支持并发处理
- **确定性随机**：使用固定随机种子确保结果可复现

### 2.2 并发控制机制

- **35,000个观众进程**：每个观众独立并发执行完整流程
- **1个监控进程**：定期记录系统状态快照
- **SimPy事件调度器**：自动处理时间推进和资源竞争

---

## 👥 3. 单个观众完整流程

### 3.1 阶段1：交通延迟模拟

```python
def get_transport_delay(self):
    # 根据概率分布选择交通方式
    mode = self.random_state.choice(
        list(cfg.TRANSPORT_PROBS.keys()), 
        p=list(cfg.TRANSPORT_PROBS.values())
    )
    
    delay = 0
    if mode == "自驾":
        # 正态分布：均值5分钟，标准差2分钟
        delay = self.random_state.normal(cfg.DRIVE_DELAY_MEAN_S, cfg.DRIVE_DELAY_STD_S)
    elif mode == "公交":
        # 均匀分布：0-8分钟
        delay = self.random_state.uniform(cfg.BUS_DELAY_MIN_S, cfg.BUS_DELAY_MAX_S)
    
    return max(0, delay)
```

**交通方式概率分布**：
- 自驾：30% → 正态分布延迟
- 公交：40% → 均匀分布延迟
- 出租车：15% → 无延迟
- 步行：10% → 无延迟
- 自行车：5% → 无延迟

### 3.2 阶段2：公园内步行

```python
def get_path_details(self):
    # 路径长度：100-500米均匀分布
    path_length = self.random_state.uniform(cfg.PATH_LENGTH_MIN_M, cfg.PATH_LENGTH_MAX_M)
    # 随机扰动：1-3分钟均匀分布
    random_delay = self.random_state.uniform(cfg.PATH_DISTURBANCE_MIN_S, cfg.PATH_DISTURBANCE_MAX_S)
    return path_length, random_delay

# 在spectator_process中执行：
path_length, random_delay = self.get_path_details()
stats.walk_duration = path_length / cfg.BASE_WALKING_SPEED_MPS  # 基础步行时间
stats.walk_delay_random = random_delay                         # 随机扰动时间
yield self.env.timeout(stats.walk_duration)                    # 执行步行
yield self.env.timeout(stats.walk_delay_random)                # 执行随机扰动
```

**步行模型参数**：
- **基础速度**：1.2米/秒
- **路径长度**：100-500米（均匀分布）
- **随机扰动**：1-3分钟（模拟意外情况、拍照等）。此部分耗时独立记录，但在最终的总耗时中体现。

### 3.3 阶段3：智能安检大棚选择

```python
# 3.1 大棚级别选择：比较南北两个大棚的总排队人数
north_queue = sum(len(res.queue) for res in self.north_lanes)
south_queue = sum(len(res.queue) for res in self.south_lanes)
chosen_tent_lanes = self.north_lanes if north_queue <= south_queue else self.south_lanes

# 3.2 通道级别选择：在选定大棚内选择排队最少的具体通道
chosen_lane = min(chosen_tent_lanes, key=lambda r: len(r.queue))
```

**智能调度算法**：
1. **第一层决策**：南北大棚选择
   - 实时比较两个大棚的总排队人数
   - 选择排队人数少的大棚
2. **第二层决策**：具体通道选择
   - 在选定大棚内比较各通道排队情况
   - 选择排队最少的通道
3. **动态更新**：每个观众到达时重新评估

### 3.4 阶段4：复杂安检处理过程

```python
with chosen_lane.request() as request:
    yield request  # 排队等待通道可用
    stats.security_queue_wait_time = self.env.now - security_queue_start_time
    
    security_process_start_time = self.env.now
    
    # 安检失败重试循环
    while self.random_state.rand() < cfg.SECURITY_FAILURE_RATE:
        process_time = self.random_state.exponential(cfg.SECURITY_CHECK_TIME_MEAN_S)
        yield self.env.timeout(process_time)  # 失败处理时间

    # 正常安检处理
    process_time = self.random_state.exponential(cfg.SECURITY_CHECK_TIME_MEAN_S)
    yield self.env.timeout(process_time)
    
    stats.security_process_time = self.env.now - security_process_start_time

    # 通道故障处理
    if self.random_state.rand() < cfg.LANE_FAILURE_PROB_PER_PERSON:
        failure_duration = self.random_state.uniform(
            cfg.LANE_FAILURE_DURATION_MIN_S,
            cfg.LANE_FAILURE_DURATION_MAX_S
        )
        yield self.env.timeout(failure_duration)  # 故障恢复时间
```

**安检处理的多层复杂性**：
1. **排队等待**：使用SimPy资源管理器处理排队逻辑
2. **失败重试**：2%概率安检失败，需要立即重新安检
3. **正常处理**：指数分布时间（均值15秒）
4. **设备故障**：0.1%概率通道故障，停用2-10分钟

### 3.5 阶段5：动态下行方式选择

```python
# 初始概率设置
use_escalator_prob = cfg.DESCEND_INITIAL_PROBS['escalator']  # 40%

# 动态概率调整
if len(self.escalator.queue) > cfg.ESCALATOR_QUEUE_THRESHOLD_FOR_ADJUST:
    use_escalator_prob = cfg.DESCEND_ADJUSTED_PROBS['escalator']  # 降至30%

# 根据调整后概率选择下行方式
if self.random_state.rand() < use_escalator_prob:
    # 选择扶梯
    stats.descend_method = "escalator"
    with self.escalator.request() as request:
        yield request
        stats.descend_queue_wait_time = self.env.now - descend_queue_start_time
        descend_process_start_time = self.env.now
        yield self.env.timeout(1 / cfg.ESCALATOR_CAPACITY_PER_SEC)
        stats.descend_process_time = self.env.now - descend_process_start_time
else:
    # 选择楼梯
    stats.descend_method = "stairs"
    with self.stairs.request() as request:
        yield request
        stats.descend_queue_wait_time = self.env.now - descend_queue_start_time
        descend_process_start_time = self.env.now
        yield self.env.timeout(cfg.STAIRS_PERSON_CROSS_TIME_S)
        stats.descend_process_time = self.env.now - descend_process_start_time
```

**动态决策机制**：
- **初始状态**：扶梯40%，楼梯60%
- **拥堵调整**：扶梯队列>50人时，扶梯概率降至30%，楼梯升至70%
- **实时感知**：每个观众都能感知当前队列状态并智能决策

---

## 📊 4. 系统监控机制

### 4.1 实时状态监控

```python
def monitor(self):
    """定期记录系统状态快照"""
    while True:
        state = {
            "时间(s)": self.env.now,
            "北侧安检队列总人数": sum(len(r.queue) for r in self.north_lanes),
            "南侧安检队列总人数": sum(len(r.queue) for r in self.south_lanes),
            "北侧安检区使用中通道数": sum(r.count for r in self.north_lanes),
            "南侧安检区使用中通道数": sum(r.count for r in self.south_lanes),
            "电梯队列人数": len(self.escalator.queue),
            "电梯使用中人数": self.escalator.count,
            "楼梯使用中人数": self.stairs.count,
            "楼梯密度(人/米)": self.stairs.count / cfg.STAIRS_WIDTH_M
        }
        self.system_state_log.append(state)
        yield self.env.timeout(cfg.MONITOR_INTERVAL_S)  # 每60秒记录一次
```

### 4.2 监控指标体系

**队列监控**：
- 南北安检区队列长度
- 扶梯排队人数
- 实时队列状态变化

**资源利用率**：
- 安检通道使用率
- 扶梯利用率
- 楼梯人流密度

**系统性能**：
- 时间序列数据
- 峰值负载统计
- 瓶颈识别指标

---

## 🔄 5. 仿真执行流程

### 5.1 主控制循环

```python
def run(self):
    """运行完整仿真"""
    print("仿真开始...")
    self.setup()                                    # 初始化所有观众和监控器
    self.env.run(until=cfg.SIMULATION_DURATION_SECONDS)  # 运行3.5小时仿真
    print("仿真结束。")
```

### 5.2 事件调度机制

**SimPy离散事件调度**：
- 自动时间推进
- 事件优先级管理
- 资源竞争处理
- 并发进程协调

**进程管理**：
- 35,000个观众进程并发运行
- 1个系统监控进程
- 动态资源分配和释放

---

## 📈 6. 数据收集和输出

### 6.1 个体数据收集

```python
def to_dict(self):
    """将观众数据转换为字典格式"""
    return {
        "ID": self.id,
        "到达公园时间": self.arrival_time,
        "交通延迟": self.transport_delay,
        "步行时长": self.walk_duration,
        "安检排队时长": self.security_queue_wait_time,
        "安检处理时长": self.security_process_time,
        "下楼排队时长": self.descend_queue_wait_time,
        "下楼过程时长": self.descend_process_time,
        "下行方式": self.descend_method,
        "完成进站时间": self.finish_time,
        "是否在规定时间内完成": self.is_finished,
        "总耗时": self.total_time()
    }
```

### 6.2 系统状态数据收集

仿真过程中的 `monitor` 进程会定期（例如每60秒）采集系统全局状态的快照，形成时间序列数据，用于分析系统负载和瓶颈随时间的变化。采集的数据点见4.1节。

---

## 🔬 7. 结果分析与汇总

仿真产生的原始数据（个体日志和系统快照）需要经过处理才能转化为有价值的洞察。`main.py` 中的 `create_summary` 函数负责这一关键任务，它计算一系列核心性能指标（KPIs），并生成一份结构化的汇总报告。

### 7.1 效率指标

- **总完成率 (%)**: 在规定的仿真时长（3.5小时）内成功完成进站的观众占总人数的比例。这是衡量系统整体吞吐能力的核心指标。
- **平均进站时间 (分钟)**: 所有完成进站的观众，从到达公园到最终完成下楼过程的平均总耗时。

### 7.2 排队指标

- **最大队列长度 (人)**: 监控并记录仿真期间，南北两侧安检区和电梯等待区的历史最大排队人数。这有助于识别瞬时拥堵的峰值。
- **平均队列长度 (人)**: 各个等待区在整个仿真过程中的平均排队人数，反映了常态下的拥堵水平。

### 7.3 资源利用率

- **安检通道利用率 (%)**: 统计南北两侧及整体安检通道在工作时间内的平均占用率。计算公式为 `(通道使用总时长 / (通道数量 * 仿真总时长)) * 100%`。
- **电梯利用率 (%)**: 统计电梯资源的平均占用率，反映这一关键路径的繁忙程度。

### 7.4 瓶颈分析

通过分析已完成观众的各项耗时数据，定位流程瓶颈：
- **各环节平均耗时 (分钟)**: 分别计算交通延迟、园内步行、安检排队、安检处理、下楼排队、下楼过程等每个阶段的平均耗时，用于比较哪一环节是主要的时间消耗点。
- **排队时间波动性 (标准差)**: 计算安检排队和下楼排队时间的标准差，高标准差意味着排队体验非常不稳定，部分观众可能会经历远超平均值的等待。

### 7.5 关键节点分析

- **楼梯使用分析**:
    - **最大/平均使用人数**: 记录楼梯上的最大和平均瞬时人数。
    - **最大/平均密度 (人/米)**: 根据楼梯容量和使用人数计算密度，评估拥挤程度和安全性。
- **下行方式选择分析**:
    - **选择人数与比例 (%)**: 统计最终选择电梯和选择楼梯的观众人数及各自占比，验证动态调整策略的效果。

---

## 📄 8. 数据输出

仿真结束后，所有收集和分析的数据将被整合并输出到一个Excel文件中（默认为 `output/simulation_results.xlsx`），包含三个不同的工作表(Sheet)：

1.  **`仿真结果汇总`**:
    - **内容**: 包含第7节中描述的所有汇总分析指标（KPIs），如完成率、平均耗时、最大队列、资源利用率等。
    - **用途**: 为决策者提供一个高度浓缩、一目了然的仿真结果概览，用于快速评估和对比不同方案。

2.  **`所有观众详细数据`**:
    - **内容**: 包含35,000名观众中每一位的详细旅程数据。每一行代表一个观众，每一列是一个具体的时间指标（如到达时间、各项排队和处理耗时、总耗时等）。
    - **用途**: 用于深度数据分析、统计分布研究（如总耗时的P95/P99分位数）、以及对特定异常个体行为的追溯。

3.  **`系统状态监控`**:
    - **内容**: `monitor`进程记录的系统状态时间序列数据。每一行是一个时间点的快照，列包括当时的安检队列人数、资源使用数、电梯队列等。
    - **用途**: 用于绘制系统状态随时间变化的趋势图，直观地观察拥堵的形成、高峰的出现时间以及系统恢复的过程，从而精准定位瓶颈发生的时间窗口。

---

