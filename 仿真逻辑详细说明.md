# 安检仿真系统详细逻辑说明

## 概述

这个仿真系统基于**SimPy离散事件仿真框架**，模拟35,000名观众在3.5小时内通过安检进站的完整过程。系统通过精确建模每个观众的完整旅程，为大型活动安检规划提供科学的决策支持。

---

## 🏗️ 1. 核心架构

### 1.1 SpectatorStats类 - 观众数据记录器

每个观众都有一个专属的数据记录器，追踪其在仿真过程中每个环节的详细时间数据：

```python
class SpectatorStats:
    def __init__(self, id, arrival_time):
        self.id = id                          # 观众唯一标识
        self.arrival_time = arrival_time      # 到达公园时间
        self.transport_delay = 0              # 交通延迟时间
        self.walk_duration = 0                # 步行耗时
        self.security_queue_wait_time = 0     # 安检排队等待时间
        self.security_process_time = 0        # 安检处理时间
        self.descend_queue_wait_time = 0      # 下楼排队等待时间
        self.descend_process_time = 0         # 下楼过程时间
        self.descend_method = ""              # 下行方式选择
        self.finish_time = -1                 # 完成进站时间
        self.is_finished = False              # 是否成功完成
```

**关键特性**：
- 完整生命周期追踪
- 多维度时间记录
- 个性化行为标记

### 1.2 Simulation类 - 仿真主控制器

```python
class Simulation:
    def __init__(self):
        self.env = simpy.Environment()        # SimPy仿真环境
        self.random_state = np.random.RandomState(cfg.RANDOM_SEED)
        
        # 资源定义
        self.security_lanes = [...]           # 12条安检通道
        self.north_lanes = [...]              # 北侧6条通道
        self.south_lanes = [...]              # 南侧6条通道
        self.escalator = simpy.Resource(...)  # 扶梯资源
        self.stairs = simpy.Resource(...)     # 楼梯资源（无限容量）
        
        # 数据收集
        self.spectator_stats = []             # 所有观众数据
        self.system_state_log = []            # 系统状态监控数据
```

**架构亮点**：
- 资源池管理（安检通道、扶梯、楼梯）
- 南北分区策略
- 双重数据收集机制

---

## 🎯 2. 仿真初始化流程

### 2.1 观众生成策略

```python
def setup(self):
    self.env.process(self.monitor())          # 启动系统监控器
    for i in range(cfg.TOTAL_SPECTATORS):    # 生成35,000名观众
        # 观众在3.5小时内均匀随机到达
        arrival_time = self.random_state.uniform(0, cfg.SIMULATION_DURATION_SECONDS)
        self.env.process(self.spectator_arrival(i, arrival_time))
```

**关键设计决策**：
- **均匀分布到达**：模拟观众在整个时间窗口内持续到达
- **独立进程**：每个观众都是独立的仿真进程，支持并发处理
- **确定性随机**：使用固定随机种子确保结果可复现

### 2.2 并发控制机制

- **35,000个观众进程**：每个观众独立并发执行完整流程
- **1个监控进程**：定期记录系统状态快照
- **SimPy事件调度器**：自动处理时间推进和资源竞争

---

## 👥 3. 单个观众完整流程

### 3.1 阶段1：交通延迟模拟

```python
def get_transport_delay(self):
    # 根据概率分布选择交通方式
    mode = self.random_state.choice(
        list(cfg.TRANSPORT_PROBS.keys()), 
        p=list(cfg.TRANSPORT_PROBS.values())
    )
    
    delay = 0
    if mode == "自驾":
        # 正态分布：均值5分钟，标准差2分钟
        delay = self.random_state.normal(cfg.DRIVE_DELAY_MEAN_S, cfg.DRIVE_DELAY_STD_S)
    elif mode == "公交":
        # 均匀分布：0-8分钟
        delay = self.random_state.uniform(cfg.BUS_DELAY_MIN_S, cfg.BUS_DELAY_MAX_S)
    
    return max(0, delay)
```

**交通方式概率分布**：
- 自驾：30% → 正态分布延迟
- 公交：40% → 均匀分布延迟
- 出租车：15% → 无延迟
- 步行：10% → 无延迟
- 自行车：5% → 无延迟

### 3.2 阶段2：公园内步行

```python
def get_path_details(self):
    # 路径长度：100-500米均匀分布
    path_length = self.random_state.uniform(cfg.PATH_LENGTH_MIN_M, cfg.PATH_LENGTH_MAX_M)
    # 随机扰动：1-3分钟均匀分布
    random_delay = self.random_state.uniform(cfg.PATH_DISTURBANCE_MIN_S, cfg.PATH_DISTURBANCE_MAX_S)
    return path_length, random_delay

# 在spectator_process中执行：
path_length, stats.walk_delay_random = self.get_path_details()
stats.walk_duration = path_length / cfg.BASE_WALKING_SPEED_MPS  # 基础步行时间
yield self.env.timeout(stats.walk_duration)                    # 执行步行
yield self.env.timeout(stats.walk_delay_random)                # 随机扰动
```

**步行模型参数**：
- **基础速度**：1.2米/秒
- **路径长度**：100-500米（均匀分布）
- **随机扰动**：1-3分钟（模拟意外情况、拍照等）

### 3.3 阶段3：智能安检大棚选择

```python
# 3.1 大棚级别选择：比较南北两个大棚的总排队人数
north_queue = sum(len(res.queue) for res in self.north_lanes)
south_queue = sum(len(res.queue) for res in self.south_lanes)
chosen_tent_lanes = self.north_lanes if north_queue <= south_queue else self.south_lanes

# 3.2 通道级别选择：在选定大棚内选择排队最少的具体通道
chosen_lane = min(chosen_tent_lanes, key=lambda r: len(r.queue))
```

**智能调度算法**：
1. **第一层决策**：南北大棚选择
   - 实时比较两个大棚的总排队人数
   - 选择排队人数少的大棚
2. **第二层决策**：具体通道选择
   - 在选定大棚内比较各通道排队情况
   - 选择排队最少的通道
3. **动态更新**：每个观众到达时重新评估

### 3.4 阶段4：复杂安检处理过程

```python
with chosen_lane.request() as request:
    yield request  # 排队等待通道可用
    stats.security_queue_wait_time = self.env.now - security_queue_start_time
    
    security_process_start_time = self.env.now
    
    # 安检失败重试循环
    while self.random_state.rand() < cfg.SECURITY_FAILURE_RATE:
        process_time = self.random_state.exponential(cfg.SECURITY_CHECK_TIME_MEAN_S)
        yield self.env.timeout(process_time)  # 失败处理时间

    # 正常安检处理
    process_time = self.random_state.exponential(cfg.SECURITY_CHECK_TIME_MEAN_S)
    yield self.env.timeout(process_time)
    
    stats.security_process_time = self.env.now - security_process_start_time

    # 通道故障处理
    if self.random_state.rand() < cfg.LANE_FAILURE_PROB_PER_PERSON:
        failure_duration = self.random_state.uniform(
            cfg.LANE_FAILURE_DURATION_MIN_S,
            cfg.LANE_FAILURE_DURATION_MAX_S
        )
        yield self.env.timeout(failure_duration)  # 故障恢复时间
```

**安检处理的多层复杂性**：
1. **排队等待**：使用SimPy资源管理器处理排队逻辑
2. **失败重试**：2%概率安检失败，需要立即重新安检
3. **正常处理**：指数分布时间（均值15秒）
4. **设备故障**：0.1%概率通道故障，停用2-10分钟

### 3.5 阶段5：动态下行方式选择

```python
# 初始概率设置
use_escalator_prob = cfg.DESCEND_INITIAL_PROBS['escalator']  # 40%

# 动态概率调整
if len(self.escalator.queue) > cfg.ESCALATOR_QUEUE_THRESHOLD_FOR_ADJUST:
    use_escalator_prob = cfg.DESCEND_ADJUSTED_PROBS['escalator']  # 降至30%

# 根据调整后概率选择下行方式
if self.random_state.rand() < use_escalator_prob:
    # 选择扶梯
    stats.descend_method = "escalator"
    with self.escalator.request() as request:
        yield request
        stats.descend_queue_wait_time = self.env.now - descend_queue_start_time
        descend_process_start_time = self.env.now
        yield self.env.timeout(1 / cfg.ESCALATOR_CAPACITY_PER_SEC)
        stats.descend_process_time = self.env.now - descend_process_start_time
else:
    # 选择楼梯
    stats.descend_method = "stairs"
    with self.stairs.request() as request:
        yield request
        stats.descend_queue_wait_time = self.env.now - descend_queue_start_time
        descend_process_start_time = self.env.now
        yield self.env.timeout(cfg.STAIRS_PERSON_CROSS_TIME_S)
        stats.descend_process_time = self.env.now - descend_process_start_time
```

**动态决策机制**：
- **初始状态**：扶梯40%，楼梯60%
- **拥堵调整**：扶梯队列>50人时，扶梯概率降至30%，楼梯升至70%
- **实时感知**：每个观众都能感知当前队列状态并智能决策

---

## 📊 4. 系统监控机制

### 4.1 实时状态监控

```python
def monitor(self):
    """定期记录系统状态快照"""
    while True:
        state = {
            "时间(s)": self.env.now,
            "北侧安检队列总人数": sum(len(r.queue) for r in self.north_lanes),
            "南侧安检队列总人数": sum(len(r.queue) for r in self.south_lanes),
            "北侧安检区使用中通道数": sum(r.count for r in self.north_lanes),
            "南侧安检区使用中通道数": sum(r.count for r in self.south_lanes),
            "电梯队列人数": len(self.escalator.queue),
            "电梯使用中人数": self.escalator.count,
            "楼梯使用中人数": self.stairs.count,
            "楼梯密度(人/米)": self.stairs.count / cfg.STAIRS_WIDTH_M
        }
        self.system_state_log.append(state)
        yield self.env.timeout(cfg.MONITOR_INTERVAL_S)  # 每60秒记录一次
```

### 4.2 监控指标体系

**队列监控**：
- 南北安检区队列长度
- 扶梯排队人数
- 实时队列状态变化

**资源利用率**：
- 安检通道使用率
- 扶梯利用率
- 楼梯人流密度

**系统性能**：
- 时间序列数据
- 峰值负载统计
- 瓶颈识别指标

---

## 🔄 5. 仿真执行流程

### 5.1 主控制循环

```python
def run(self):
    """运行完整仿真"""
    print("仿真开始...")
    self.setup()                                    # 初始化所有观众和监控器
    self.env.run(until=cfg.SIMULATION_DURATION_SECONDS)  # 运行3.5小时仿真
    print("仿真结束。")
```

### 5.2 事件调度机制

**SimPy离散事件调度**：
- 自动时间推进
- 事件优先级管理
- 资源竞争处理
- 并发进程协调

**进程管理**：
- 35,000个观众进程并发运行
- 1个系统监控进程
- 动态资源分配和释放

---

## 📈 6. 数据收集和输出

### 6.1 个体数据收集

```python
def to_dict(self):
    """将观众数据转换为字典格式"""
    return {
        "ID": self.id,
        "到达公园时间": self.arrival_time,
        "交通延迟": self.transport_delay,
        "步行时长": self.walk_duration,
        "安检排队时长": self.security_queue_wait_time,
        "安检处理时长": self.security_process_time,
        "下楼排队时长": self.descend_queue_wait_time,
        "下楼过程时长": self.descend_process_time,
        "下行方式": self.descend_method,
        "完成进站时间": self.finish_time,
        "是否在规定时间内完成": self.is_finished,
        "总耗时": self.total_time()
    }
```

### 6.2 数据输出格式

```python
def get_results(self):
    """生成分析用的DataFrame"""
    spectator_df = pd.DataFrame([s.to_dict() for s in self.spectator_stats])
    system_df = pd.DataFrame(self.system_state_log)
    return spectator_df, system_df
```

**输出文件结构**：
- `spectator_df`：35,000行观众个体数据
- `system_df`：系统状态时间序列数据
- Excel多工作表输出格式

---

